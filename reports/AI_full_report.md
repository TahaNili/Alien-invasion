گزارش کامل هوش مصنوعی (AI) در پروژه Alien-invasion

هدف: این گزارش صفر تا صد رفتار AI در این پروژه را با ارجاع به فایل‌ها و توابع مربوطه شرح می‌دهد تا توسعه‌دهنده‌ای که با کد آشنا نیست بتواند بفهمد AI چگونه تصمیم می‌گیرد، چگونه عمل می‌کند و کدام بخش‌های کد با آن در تعامل‌اند.

1) مروری سریع

- مکان اصلی پیاده‌سازی AI: `src/ai_manager.py` (کلاس `AIManager`).
- نقشی که AI بازی می‌کند: تصمیم‌گیری هر فریم در مورد حرکت (چپ/راست/بالا/پایین) و شلیک گلوله. AI تلاش می‌کند مانند بازیکن رفتار کند و برای شلیک از قراردادهای بازیکن استفاده کند (تعیین زاویهٔ کشتی و استفاده از مسیر شلیک بازیکن).
- مسیر فراخوانی AI: در `alien_invasion.py`، هر فریم قبل از هندل کردن ورودی‌ها و سپس دوباره قبل از به‌روزرسانی اسپرايت‌ها، `ai_manager.act(...)` فراخوانی می‌شود؛ بدین ترتیب AI می‌تواند وضعیت موس/کیبورد را شبیه‌سازی کرده و این وضعیت در همان فریم توسط کد ورودی دیده شود.

2) فایل‌ها و نقاط کلیدی که AI را به کار می‌اندازند

- `alien_invasion.py`
  - AIManager در ابتدای `run_game()` ساخته می‌شود و هر فریم (قبل از هندل رویدادها و قبل از به‌روزرسانی اسپرايت‌ها) اجرا می‌شود:
    - خط مربوطه: `ai_manager.act( ... input, ...)`
  - AI می‌تواند به‌صورت خودکار فعال شود اگر کاربر برای مدتی غیرفعال بماند. کلید `K` برای روشن/خاموش کردن AI وجود دارد.

- `src/ai_manager.py` (فایل اصلی)
  - کلاس `AIManager`:
    - وظایف: بارگذاری مدل‌های train شده از پوشه `models` (logreg/rf/knn) با `joblib` (در صورتی که موجود باشند)، فراهم کردن متد `predict_fire(...)` برای تصمیم‌گیری شلیک مبتنی بر مدل، و متد `act(...)` که رفتار AI را هر فریم اجرا می‌کند.
    - در سازنده (`__init__`) به‌صورت اختیاری یک نخ پس‌زمینه برای اجرای اسکریپت آموزش (`tools/train_imitation.py`) دارد که مدل‌ها را هر چند وقت یک‌بار دوباره می‌سازد (اگر `trainer_cmd` تنظیم شده باشد).

  - `predict_fire(stats, ship, aliens, bullets, health, input)`:
    - اقدامات: بردن وضعیت بازی به یک بردار ویژگیِ ردیفی (score, ships_left, hearts, ship_x, ship_y, ship_angle, حرکت‌های کشتی، تعداد گلوله‌ها، تعداد بیگانگان، بردار به نزدیک‌ترین بیگانه و فاصله)
    - سپس اگر یکی از مدل‌های `logreg`, `rf`, یا `knn` لود شده باشد، پیش‌بینی انجام می‌دهد (اول با `predict()`, سپس اگر خطا رخ دهد با `predict_proba()` و آستانه 0.5).
    - اگر مدل نباشد یا خطایی رخ دهد، مقدار False باز می‌گرداند.

  - `act(stats, ship, aliens, bullets, health, input, ...)`:
    - High-level behaviour pipeline:
      1. ساخت بافرهای کلید و موس برای شبیه‌سازی ورودی بازیکن (لیست/tuple از حالت کلیدها و دکمه‌های موس). این بافرها در پایان متد با `commit_input_states()` در آبجکت `input` کپی می‌شوند تا باقی کد بازی این تغییرات را ببیند.
      2. جمع کردن آیتم‌ها: اگر آیتمی نزدیک باشد (حد آستانه)، به سمت آن حرکت می‌کند.
      3. جاخالی دادن از گلوله‌های دشمن: اگر گلوله‌ای نزدیک و تهدیدکننده باشد، با استفاده از شبیه‌سازی کلیدها از مسیر گلوله دوری می‌کند.
      4. هدف‌گیری و حمله: نزدیک‌ترین بیگانه را انتخاب می‌کند، فاصله را حساب می‌کند، در صورت دور بودن حرکت می‌کند و در فاصله مناسب اقدام به هدف‌گیری و احتمالاً شلیک می‌کند.
         - برای تصمیمِ شلیک، ابتدا `predict_fire()` فراخوانی می‌شود. اگر مدل گفت شلیک کن، AI زاویهٔ هدف (آیم) را با حل مسئله برهم‌کنش گلوله-بیگانه (حل یک معادله درجه 2 برای زمان رهگیری) محاسبه می‌کند و سپس سعی می‌کند که با قرارداد بازیکن شلیک کند:
           - پرچم `ship._ai_requested_fire = True` تنظیم می‌شود (برای رکوردر)
           - `input.current_mouse_position` به مختصات هدف تنظیم می‌شود تا `ship.update()` همان زاویه را محاسبه کند.
           - `set_mouse_press(left=True)` فراخوانی می‌شود تا شبیه‌سازی فشردن یک فریمِ دکمهٔ موس چپ انجام شود.
           - همچنین `ship.angle` به `fire_angle` نیز نوشته می‌شود تا هماهنگی فوری بین ظاهر و گلوله تضمین شود.
         - اگر هر کدام از مراحل بالا شکست بخورد، مسیر پشتیبان مستقیم `gf.fire_bullet(ship, bullets, angle=fire_angle)` یا `gf.fire_bullet(ship, bullets)` استفاده می‌شود.
    - در پایان، بافرهای کلید و موس ساخته شده به آبجکت `input` اعمال می‌شوند تا سایر بخش‌های بازی همانند یک بازیکن واقعی این ورودی‌های شبیه‌سازی شده را بخوانند.

- `src/recorder.py`
  - Recorder برای ثبت داده‌های رویدادهای بازی استفاده می‌شود. Recorder از پرچم `ship._ai_requested_fire` پشتیبانی می‌کند؛ اگر AI آن را ست کند، ردیابی می‌شود و سپس پرچم پاک می‌شود تا دوباره آماده استفاده شود.
  - این طراحی اطمینان می‌دهد که شلیک‌های AI در خروجی رکوردر مشابه شلیک‌های واقعی ثبت می‌شوند.

- `src/game_functions.py`
  - نقطهٔ تصمیم‌گیری کاربر: `check_events()` -> `check_mouse_events()` و `check_key_events()`؛ AI سعی می‌کند با اعمال تغییرات در آبجکت `input` این مسیرها را فعال کند.
  - `fire_bullet(ship, bullets, angle=None)` یک نقطهٔ مرکزی برای ایجاد گلوله‌هاست. اکنون AI از این مسیر غیرمستقیم استفاده می‌کند (اگر شبیه‌سازی ورودی موفقیت‌آمیز نباشد، fallback دارد).

- `src/bullet.py`
  - `ShipBullet` از زاویهٔ کشتی برای محاسبهٔ محل اسپاون گلوله استفاده می‌کند. منطق spawn به‌طوری نوشته شده است که گلوله از "تفنگ چپ" کشتی خارج شود (با آفست‌های forward=30px و lateral_left≈-12px، بسته به جهت). این بخشی بود که شما خواستید حفظ شود.

- `src/alien.py`, `src/ship.py` و دیگر فایل‌ها
  - تغییرات نقدی: برای اهداف رهگیری بهتر، یک فیلد `vx, vy` به بیگانگان اضافه شده است تا سرعت را ثبت کند و AI بتواند پیش‌بینی دقیق‌تری برای رهگیری انجام دهد. (این تغییرات در پیاده‌سازی قبلی اضافه شده‌اند؛ فایل‌ها را برای جزئیات بررسی کنید.)

3) جریان داده‌ای و ترتیب فراخوانی‌ها در یک فریم

- ترتیب مهم است و طوری طراحی شده که AI بتواند "مانند یک بازیکن" عمل کند:
  1. `input.update()` — خواندن وضعیت فعلی از Pygame و بروزرسانی توابع دوتایی/طول فشردن کلیدها.
  2. `ai_manager.act(...)` — AI می‌تواند بافر ورودی را به‌روز کند. این فراخوانی یکی از دلایل اصلی جابه‌جایی AI به قبل از `check_events()` بود.
  3. `recorder.record(...)` — رکوردر وضعیت فعلی و پرچم‌های AI را می‌خواند و ثبت می‌کند.
  4. `check_events()` — تابع اصلی که `check_key_events()` و `check_mouse_events()` را فراخوانی می‌کند؛ این توابع الان ورودی‌های شبیه‌سازی شده توسط AI را می‌خوانند.
  5. اگر `stats.game_active` است، دوباره `ai_manager.act(...)` فراخوانی می‌شود (هدف: اعمال حرکت AI درست قبل از `ship.update()` تا حرکت در همان فریم اعمال شود).
  6. `gf.update_game_sprites(...)` — اجرای `ship.update()`، `bullets.update()` و بقیه که حالا ورودی AI را اعمال می‌کند.

4) نکاتی که باید توسعه‌دهنده بداند (مشکلات و راه‌حل‌ها)

- سابقهٔ مدل ML و پایداری:
  - کد فعلی از joblib و مدل‌های logreg/rf/knn پشتیبانی می‌کند. اما اگر مدل‌ها موجود نباشند، روشِ fall back به heuristics باز می‌گردد.
  - برای ثبات، پیشنهاد شده است که ابتدا AI را با یک heuristic قوی جایگزین کنید و در آینده ML را به‌عنوان ضمیمه اضافه کنید.

- شبیه‌سازی ورودی و سازگاری با رکوردر:
  - `ship._ai_requested_fire` برای سازگاری با Recorder وجود دارد و باید هر زمانی که AI قصد شلیک دارد ست شود.
  - Recorder این پرچم را می‌خواند و در CSV خروجی، `mouse_fire` را برابر 1 قرار می‌دهد.

- debounce و محدودیت نرخ شلیک:
  - `fire_bullet` یک debounce داخلی دارد که جلوی شلیک دوبل در همان tick را می‌گیرد (استفاده از `pygame.time.get_ticks()` و `_last_fire_tick` روی شیٔ ship).
  - این تضمین می‌کند که حتی اگر AI چند بار در یک فریم سعی در شلیک داشته باشد، تنها یک گلوله تولید شود.

- مشکلات اجرایی که در طی بازبینی دیده شد:
  - در تست headless ما، TextureAtlas ممکن است بارگذاری نشده باشد و `TextureAtlas.get_sprite_texture()` پیغام "Sprite textures are not loaded" چاپ کند که منجر به خطا در سازندهٔ Bullet شود. برای تست‌های headless یا CI، باید یک fallback برای تصویر گلوله قرار داده شود یا TextureAtlas با مسیرهای درست مقداردهی شود.
  - `Input` باید مقاوم در مقابل حالات غیرعادی باشد؛ در پیاده‌سازی فعلی من اصلاحاتی برای جلوگیری از IndexError هنگامیکه AI بافرهای کلیدی با اندازهٔ متفاوت می‌نویسد اضافه کردم.

5) فهرست کامل توابع/مکان‌هایی که به AI مربوط‌اند (کلیدها و توضیح مختصر)

- `alien_invasion.py`
  - ساخت `AIManager` و فراخوانی `ai_manager.act(...)` در دو نقطه هر فریم.
  - کلید K برای toggling AI.
  - منطق auto-enable AI در صورت بیکاری کاربر.

- `src/ai_manager.py`
  - `AIManager.__init__()` — بارگذاری مدل‌ها، راه‌اندازی نخ آموزش پس‌زمینه (اختیاری).
  - `load_models()` — بارگذاری joblib model files.
  - `predict_fire(stats, ship, aliens, bullets, health, input)` — ساخت بردار ویژگی و فراخوانی مدل برای تصمیم شلیک.
  - `act(stats, ship, aliens, bullets, health, input, ...)` — منطق تصمیم‌گیری بالا (collect -> dodge -> attack) + شبیه‌سازی input buffers و commit.
  - توابع کمکی در `act()`: `set_key_state`, `set_mouse_press`, `commit_input_states`, `move_toward`, و محاسبهٔ intercept (حل معادله درجه دو).

- `src/recorder.py`
  - خواندن `ship._ai_requested_fire` و نگاشتن آن به `mouse_fire` در خروجی رکورد.

- `src/game_functions.py`
  - `check_events()`, `check_key_events()`, `check_mouse_events()` — مسیر ورودی‌ای که AI شبیه‌سازی می‌کند.
  - `fire_bullet(ship, bullets, angle=None)` — نقطهٔ مرکزی ساخت گلوله و debounce. AI در حالت fallback مستقیم از `gf.fire_bullet(...)` هم استفاده می‌کند اگر شبیه‌سازی ورودی شکست بخورد.

- `src/bullet.py`
  - `ShipBullet.set_angle()` و `set_angle_override()` — محاسبهٔ زاویهٔ گلوله و Offset برای خروج از "تفنگ چپ" کشتی.

- `src/alien.py` (و به‌روزرسانی‌ها)
  - فیلدهای اضافی: `vx`, `vy` برای ذخیرهٔ سرعت، که AI از آن برای رهگیری بهتر استفاده می‌کند.

6) پیشنهادات عملی برای بهبود

- ثابت‌سازی input emulation:
  - به‌جای اینکه AI فقط تغییرات را در `input` ایجاد کند، می‌توان یک لایهٔ adapter نوشت که هم اندازهٔ tupleهای کلید را تضمین کند و هم ورود/ خروجی را ثبت (log) کند.

- ساده‌سازی وابستگی به ML در حلقهٔ اجرا:
  - حذف نخ پس‌زمینهٔ آموزش (trainer) و joblib از AI runtime، و نگه داشتن این‌ها به‌عنوان ابزارهای توسعه (offline training). در runtime فقط یک heuristic سریع اجرا شود تا رفتار پایدار بماند.

- اضافه‌کردن حالت debug و تست پوشش:
  - `AIManager` باید یک `debug` flag داشته باشد که مجموعه‌ای از مقادیر تصمیم‌گیری هر فریم (nearest alien, aim_x/aim_y, should_fire) را به لاگ بنویسد.
  - تست‌های واحد برای `compute_intercept()`، `predict_fire()` (با مدل mock یا fake) و برای مسیر کامل از `ai.act()` تا `fire_bullet` نوشته شوند.

7) فایل‌های مفید در مخزن

- `src/ai_manager.py` — فایل اصلی AI
- `alien_invasion.py` — محل ساخت AI و فراخوانی در حلقهٔ اصلی
- `src/recorder.py` — ثبت شلیک‌های AI
- `src/game_functions.py` — `fire_bullet`, `check_events`, `check_mouse_events`
- `src/bullet.py` — منطق spawn گلوله‌ها
- `src/alien.py` — موجودات دشمن (ممکن است vx/vy اضافه شده باشد)
- `docs/AI_mechanism_en.md` — شرح انگلیسی که قبلاً ساخته شده و حاوی راهنمایی‌هایی برای بهبود

8) نتیجه‌گیری

- AI در این پروژه یک controller سطح بالا است که با استفاده از (1) مدل ML در صورت موجود بودن و (2) قواعد هِیوریستیک هنگام نبود مدل، تصمیم می‌گیرد و سپس سعی می‌کند این تصمیمات را با شبیه‌سازی دقیق ورودی بازیکن (موس/کیبورد) در همان فریم اجرا کند.
- نکتهٔ کلیدی این است که AI از "قرارداد بازیکن" استفاده می‌کند تا از مسیرهای cheat یا alternate bypass جلوگیری شود — این راهکار موجب سازگاری کامل بین رفتار AI و بازیکن انسان می‌شود.
- برای بازنویسی کامل AI (که پیشتر مطرح شد)، پیشنهاد می‌کنم پیاده‌سازی جدیدی بدهیم که ساده، deterministic و با تست‌های واحد باشد و سپس مدل ML را به‌عنوان ویژگی الحاقی اضافه کنیم.

اگر مایل باشید، من می‌توانم نسخهٔ فارسی این گزارش را نیز به انگلیسی ترجمه کنم، یا بر اساس این گزارش یک پیاده‌سازی جدید (`src/ai_manager_new.py`) بسازم و آن را به‌صورت غیرمخرب جایگزین کنم — کدام را بخواهید انجام دهم؟
